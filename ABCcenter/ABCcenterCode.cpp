
/**
 * @file ABCcenterCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2024-10-01                                                                     
 **/
 
#include "ABCcenterCode.hpp"
BlinkyBlocksBlock *moduleA=nullptr;
BlinkyBlocksBlock *moduleB=nullptr;
BlinkyBlocksBlock *moduleC=nullptr;
BlinkyBlocksBlock *moduleCenter=nullptr;
int distAB, distBC, distBcenter, distCcenter;
ABCcenterCode::ABCcenterCode(BlinkyBlocksBlock *host):BlinkyBlocksBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;
    
    addMessageEventFunc2(AGRADIENT_MSG_ID,
                       std::bind(&ABCcenterCode::myAGradientFunc,this,
                       std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(ABACK_MSG_ID,
                       std::bind(&ABCcenterCode::myABackFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myElectBFunc) to the message of type L
    addMessageEventFunc2(ELECTB_MSG_ID,
                       std::bind(&ABCcenterCode::myElectBFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myBgradientFunc) to the message of type R
    addMessageEventFunc2(BGRADIENT_MSG_ID,
                       std::bind(&ABCcenterCode::myBgradientFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myBbackFunc) to the message of type C
    addMessageEventFunc2(BBACK_MSG_ID,
                       std::bind(&ABCcenterCode::myBbackFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myElectCFunc) to the message of type T
    addMessageEventFunc2(ELECTC_MSG_ID,
                       std::bind(&ABCcenterCode::myElectCFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myCgradientFunc) to the message of type I
    addMessageEventFunc2(CGRADIENT_MSG_ID,
                       std::bind(&ABCcenterCode::myCgradientFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myCbackFunc) to the message of type M
    addMessageEventFunc2(CBACK_MSG_ID,
                       std::bind(&ABCcenterCode::myCbackFunc,this,
                       std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(ELECTCENTER_MSG_ID,
                       std::bind(&ABCcenterCode::myElectCenterFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

}

void ABCcenterCode::startup() {
    console << "start " << getId() << "\n";
    myCurrentRound=0;
    myParent=nullptr;

    if (isA) { // The leader is the module 1
        module->setColor(BROWN);
        myToBPort=nullptr;
        myMaxADistance=0;
        myADistance=0;
        myCurrentRound=1;
        moduleA=module;
        myNbWaitedAnswers=sendMessageToAllNeighbors("AGrad", new MessageOf<pair<uint8_t,uint8_t>>(AGRADIENT_MSG_ID, make_pair(0,1)), 0, 0, 0);
    }
}
void ABCcenterCode::myAGradientFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    MessageOf<pair<uint8_t, uint8_t>>* msg = static_cast<MessageOf<pair<uint8_t,uint8_t>>*>(_msg.get());
    uint8_t msgDistance = (*msg->getData()).first;
    uint8_t msgRound = (*msg->getData()).second;
    console << "rec. AGrad(" << int(msgDistance) << "," << int(msgRound) << ") from " << sender->getConnectedBlockId() << "\n";

    // Apply logic similar to myBgradientFunc or myCgradientFunc
    if (msgRound > myCurrentRound) {
        myCurrentRound = msgRound;
        myADistance = 255;
        myMaxADistance=msgDistance;
        myToBPort = nullptr;
        isA=false;
        isB=false;
        isC=false;
        //setColor(DARKGREY);
    }

    if (myADistance > msgDistance) {
        myParent = sender;
        myADistance = msgDistance;
        myNbWaitedAnswers = sendMessageToAllNeighbors("AGrad", new MessageOf<pair<uint8_t,uint8_t>>(AGRADIENT_MSG_ID, make_pair(msgDistance+1, msgRound)), 0,0, 1 , myParent);
        
        if (myNbWaitedAnswers == 0) {
            sendMessage("ABack", new MessageOf<uint8_t>(ABACK_MSG_ID, uint8_t(myADistance)), myParent, 1000, 0);
        }
    } else {
        sendMessage("ABack", new MessageOf<uint8_t>(ABACK_MSG_ID, uint8_t(myADistance)), sender, 1000, 0);
    }
}
void ABCcenterCode::myABackFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface *sender) {
    MessageOf<uint8_t>* msg = static_cast<MessageOf<uint8_t>*>(_msg.get());
    uint8_t msgDistance = (*msg->getData());
    console << "rec. ABack(" << int(msgDistance) << ") from " << sender->getConnectedBlockId() << "\n";
    
    if (msgDistance > myMaxADistance) {
        myMaxADistance = msgDistance;
        myToBPort = sender;
    }
    
    myNbWaitedAnswers--;
    if (myNbWaitedAnswers == 0) {
        if (isA) {
            setColor(RED);  // Use a distinct color for the A module
            if (myToBPort != nullptr) {
                sendMessage("ElectB", new Message(ELECTB_MSG_ID), myToBPort, 1000, 0);
            }
        } else {
            sendMessage("ABack", new MessageOf<uint8_t>(ABACK_MSG_ID, uint8_t(myMaxADistance)), myParent, 1000, 0);
        }
    }
}
void ABCcenterCode::myElectBFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface *sender) {
	console<< " rec. ElectB() from " << sender-> getConnectedBlockId() << "\n";
	if (myToBPort == nullptr){
		isB=true;
		moduleB = module;
		distAB = myADistance;
		myBDistance=0;
		setColor(DARKGREEN);
		myToCPort=nullptr;
		myMaxBDistance=0;
		myNbWaitedAnswers=sendMessageToAllNeighbors("BGrad", new MessageOf<pair<uint8_t,uint8_t>>(BGRADIENT_MSG_ID, make_pair(0,1)), 0, 0,0);
	}else{
		sendMessage("ElectB", new Message(ELECTB_MSG_ID), myToBPort, 1000,0);
	}
}

void ABCcenterCode::myBgradientFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface *sender) {
	MessageOf<pair<uint8_t,uint8_t>>* msg = static_cast<MessageOf<pair<uint8_t,uint8_t>>*>(_msg.get());
	uint8_t msgDistance = (*msg-> getData()).first;
	uint8_t msgRound = (*msg->getData()).second;
	console<<"rec. BGrad(" << int(msgDistance)<< "," << int(msgRound)<<") from"<< sender->getConnectedBlockId() << "\n";
	if (msgRound>myCurrentRound){
		myCurrentRound = msgRound;
		myBDistance = 255;
		myMaxBDistance = msgDistance;
		myToCPort = nullptr;
	}
	if(myBDistance > msgDistance){
		myParent = sender;
		myBDistance = msgDistance;
		myNbWaitedAnswers = sendMessageToAllNeighbors("BGrad", new MessageOf<pair<uint8_t,uint8_t>>(BGRADIENT_MSG_ID, make_pair(myBDistance+1,myCurrentRound)), 0, 0,1 , myParent);
		if(myNbWaitedAnswers == 0){
			string str = "dB=" + to_string(myBDistance);
			module->getGlBlock()->setPopupInfo(str);
			sendMessage("BBack", new MessageOf<uint8_t>(BBACK_MSG_ID, uint8_t(myBDistance)), myParent, 1000, 0);
		}
	}else{
		sendMessage("BBack", new MessageOf<uint8_t>(BBACK_MSG_ID, uint8_t(myBDistance)), sender, 1000, 0);
	}
}

void ABCcenterCode::myBbackFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
	MessageOf<uint8_t>* msg = static_cast<MessageOf<uint8_t>*>(_msg.get());
	uint8_t msgDistance = (*msg->getData());
	console << "rec. BBack("<< int(msgDistance)<< ") from " << sender->getConnectedBlockBId() << "\n";
	if(msgDistance>myMaxBDistance){
		myMaxBDistance = msgDistance;
		myToCPort = sender;
	}
	myNbWaitedAnswers--;
	if(myNbWaitedAnswers == 0){
		string str= "dB="+to_string(myBDistance);
		module->getGlBlock()->setPopupInfo(str);
		if(isB){
			setColor(GREEN);
			if(myToCPort!=nullptr) sendMessage("ElectC", new Message(ELECTC_MSG_ID), myToCPort, 1000, 0);
		}else{
			sendMessage("BBack", new MessageOf<uint8_t>(BBACK_MSG_ID , uint8_t(myMaxBDistance)), myParent, 1000, 0);
		}
	}
}

void ABCcenterCode::myElectCFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
	console << "rec. ElectC() from " << sender->getConnectedBlockBId() << "\n";
	if(myToCPort == nullptr){
		isC = true;
		moduleC = module;
		distBC = myBDistance;
		myCDistance = 0;
		myToGPort = nullptr;
		myMinG=myBDistance;
		setColor(BLUE);
		myNbWaitedAnswers=sendMessageToAllNeighbors("CGrad", new MessageOf<pair<uint8_t,uint8_t>>(CGRADIENT_MSG_ID, make_pair(0,1)), 0, 0,0);
	}else{
		sendMessage("ElectC", new Message(ELECTC_MSG_ID),myToCPort,1000,0);
	}
	
}

void ABCcenterCode::myCgradientFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
	MessageOf<pair<uint8_t, uint8_t>>* msg = static_cast<MessageOf<pair<uint8_t,uint8_t>>*>(_msg.get());
	uint8_t msgDistance = (*msg->getData()).first;
	uint8_t msgRound = (*msg->getData()).second;
	console<<"rec, CGrad(" << int(msgDistance)<< "," << int(msgRound) <<") from " << sender-> getConnectedBlockId() << "\n";
	if(msgRound>myCurrentRound){
		myCurrentRound = msgRound;
		myCDistance = 255;
		myMinG = abs(int(msgDistance)-int(myBDistance));
		myToCPort= nullptr;
	}
	if(myCDistance>msgDistance){
		myParent = sender;
		myCDistance = msgDistance;
		int G=abs(int(myCDistance)-int(myBDistance));
		if(myMinG>=G){
			myMinG=G;
			console << "minG=abs(" << int(myCDistance) <<"-" << int(myBDistance) << ")=" << G <<"\n";
		}
		myNbWaitedAnswers=sendMessageToAllNeighbors("CGrad", new MessageOf<std::pair<uint8_t, uint8_t>>(CGRADIENT_MSG_ID, std::make_pair(myCDistance+1, myCurrentRound)), 0, 0,1 , myParent);

		if(myNbWaitedAnswers==0){
			string str="dB="+to_string(myBDistance)+"dC=" + to_string(myCDistance);
			module->getGlBlock()->setPopupInfo(str);
			sendMessage("CBack", new MessageOf<uint8_t>(CBACK_MSG_ID,uint8_t(myMinG)),myParent,1000,0);
		}
	}else{
		sendMessage("CBack", new MessageOf<uint8_t>(CBACK_MSG_ID,uint8_t(myMinG)),sender,1000,0);
	}
}

void ABCcenterCode::myCbackFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
	MessageOf<uint8_t>* msg = static_cast<MessageOf<uint8_t>*>(_msg.get());
	uint8_t msgG = (*msg->getData());
	console<< "rec. CBack(" << int(msgG) << ") from " << sender->getConnectedBlockId()<< "\n";
	if (msgG<myMinG) {
		myMinG=msgG;
		myToGPort=sender;
	}
	myNbWaitedAnswers--;
	if(myNbWaitedAnswers==0){
		string str= "dB="+to_string(myBDistance);
		module->getGlBlock()->setPopupInfo(str);
		if(isC){
			setColor(BLUE);
			
		}else{
				sendMessage("CBack", new MessageOf<uint8_t>(CBACK_MSG_ID , uint8_t(myMinG)), myParent, 1000, 0);
		}
	}
	
}
void ABCcenterCode::myElectCenterFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender){
	console<<"rec. ElectCenter() from" << sender->getConnectedBlockBId() <<"\n";
	int G=abs(int(myCDistance)-int(myBDistance));
	string str="dB=" + to_string(myBDistance)+"dC=" + to_string(myCDistance)+"G="+ to_string(G);
	module->getGlBlock()->setPopupInfo(str);
	if(G<=1){
		setColor(BROWN);
		moduleCenter=module;
		distBcenter=myBDistance;
		distCcenter=myCDistance;
		
	}else{
		setColor(YELLOW);
		sendMessage("Elect", new Message(ELECTCENTER_MSG_ID), myToGPort,1000,0);
	}
}


string ABCcenterCode::onInterfaceDraw() {
  string str="Press 'r' to run the simulation.";
  if (moduleA!= nullptr) {
    str="A= ("+moduleA->position.to_string()+")";
  }
  if (moduleB!=nullptr) {
    str+="\nB= ("+moduleB->position.to_string()+"), distAB="+ to_string(distAB);
  }
  if (moduleC!=nullptr) {
    str+="\nC= ("+moduleC->position.to_string()+"), distBC="+ to_string(distBC);
  }
  if (moduleCenter!=nullptr) {
    str+="\nCenter= ("+moduleCenter->position.to_string()+"), dist to B="+
         to_string(distBcenter)+", dist to C="+ to_string(distCcenter);
  }
  return str;
}




























